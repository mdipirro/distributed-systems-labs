\section{GAE Exercise 3.2}
\subsection{Question 1}
We let the indirect communication kick in during the quotes confirmation step. It comprises many different, time-consuming, operations and potentially operates upon a high number of quotes. Hence, decoupling front-end and back-end here, and using task queues to perform this operation, allows a parallel-processing which enables the application to scale better in case of high loads.

Quote creation might be a process-intensive operation if we did not specify a specific company in the request. This would involve a database scan to find a suitable match. Nonetheless, with the current design this is not the case, since every quotes creation request targets a specific company.

\subsection{Question 2} 
An attempt to confirm quotes results in the creation of a \texttt{QuotesStatus} objects, representing the confirmation procedure status and persisted in the datastore. We then pass to the \texttt{Worker} a \texttt{Payload} object containing the quotes list (a copy of the front-end one) and the \texttt{QuotesStatus}' ID.

It indeed makes sense to pass only a reference. This requires less data to be sent over the wire, but task has to query the datastore to retrieve the necessary information. We decided to use this approach with \texttt{QuotesStatus}, which is by definition remote: the task updates this object during its processing, and the front-end may read it at the same time. Hence, making copies could cause inconsistencies issues. On the other hand, \texttt{Quote}s are used only once (during the confirmation), and persist them before that would require additional work back-end side. We decided to send a copy of the list to the \texttt{Worker} to reduce the datastore load. Furthermore, with the current design, quotes cannot be deleted and failed quotes (possibly a high number) would remain in the datastore, unused. For the confirmed ones, there would be an unnecessary redundancy, since \texttt{Reservation}s already comprise the quote data.