\section{Design decisions}
\subsection{Remote and Serializable classes}
The three interfaces defined in the \texttt{session} package are remotely accessible (i.e. they are stereotyped with \texttt{$<<$Remote$>>$}) in the class diagram. This design choice follows the Java RMI's standard mandate. After defining the interfaces as \texttt{$<<$Remote$>>$} we can register their concrete implementation to the \texttt{rmiregister}. This allows the client to ignore any implementation details and to act only considering the remote interface. The actual code can be dynamically downloaded or distributed as a \texttt{.jar} file.

We made serializable (i.e. stereotyped as \texttt{$<<$Serializable$>>$}) only the classes intended to be marshaled and unmarshaled. These classes do not include the remote accessible ones, since for them Java RMI sends a remote reference and not an object copy. Below is a list of the serializable classes.
\begin{itemize}
	\item \texttt{ReservationException}
	\item \texttt{ReservationConstraint}
	\item \texttt{CarType}
	\item \texttt{Quote}
	\item \texttt{Reservation}
\end{itemize}
Instances of these classes are used as parameters or return values by remote object's methods. As mentioned before, Java RMI uses a pass-by-value semantics for non-remote objects, which involves marshaling and unmarshaling. Since instances of the other classes in the \texttt{rental} package are not sent over the network, those classes do not implement the \texttt{Serializable} interface. 

\subsection{Location and registration of remote objects}
%TODO

\subsection{Sessions life time management}
The manager session does not keep any conversational state, and it is represented as a simple remote objects. Managers simply obtain a reference to this object by looking up in the \texttt{rmi registry} and use this reference to invoke methods. They play no role in managing its lifetime. 

The rental session, on the other hand, keeps a conversational state and it is unique in respect of a client. \texttt{SessionManager} acts as a naming service for the rental sessions and enables a renter to create their own session. At the end of their work, the renter can end the session. The ending causes the deletion of the kept state, if any. This means if there are some unconfirmed quotes when the client closes the session, they are removed. We binds clients and session via a \texttt{Map$<$String, RentalSession$>$}, where the \texttt{String} represents the client's name, supposed to be unique.
% TODO: what if the client doesn't terminate the session? Shall we end it after a while or shell we keep it alive and return the same session if the client asks for that? 

Rental sessions are not persistent over server failures. If the server keeping the conversational state crashes, every information about the sessions, as well as every information about the reservations, is lost. We do not deal with this design issue because data persistence is not one of this assignment's goals. 

\subsection{Thread synchronization}