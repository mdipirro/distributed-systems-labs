\section{Design decisions}
\subsection{Remote and Serializable classes}
The three interfaces defined in the \texttt{session} package are remotely accessible (i.e. they are stereotyped with \texttt{$<<$Remote$>>$}) in the class diagram. This design choice follows the Java RMI's standard mandate. After defining the interfaces as \texttt{$<<$Remote$>>$} we can use them as remote objects. This allows the client to ignore any implementation details and to act only considering the remote interface. The actual code can be dynamically downloaded or distributed as a \texttt{.jar} file.

We made serializable (i.e. stereotyped as \texttt{$<<$Serializable$>>$}) only the classes intended to be marshaled and unmarshaled. These classes do not include the remote accessible ones, since for them Java RMI sends a remote reference and not an object copy. The following classes are serializable: \texttt{ReservationException}, \texttt{ReservationConstraint}, \texttt{CarType}, \texttt{Quote}, \texttt{Reservation}. Instances of these classes are used as parameters or return values by remote object's methods. As mentioned before, Java RMI uses a pass-by-value semantics for non-remote objects, which involves marshaling and unmarshaling. Since instances of the other classes in the \texttt{rental} package are not sent over the network, those classes do not implement the \texttt{Serializable} interface. 
%TODO CarRentalCompany and Car remote?? -> Probably CarRentalCompany should be a remote object as in the first assignmente (and they say that different companies may run on different servers)

\subsection{Location of remote objects} %TODO

\subsection{Registration of remote objects}
We register to the built-in RMI registry an instance of \texttt{RentalSessionManagerRemote} and an instance of \texttt{ManagerSession}. Since these two objects cannot be obtained in other ways, it is necessary to expose them using the RMI registry. On the contrary, we do not expose instances of \texttt{RentalSession}. Instances of this class are returned after an invocation of \texttt{RentalSessionManagerRemote.add}, which creates an unique session for a certain renter. Providing the access to an instance of this class via the RMI register would be wrong, since a rental session does not exists without a binding with a renter (i.e. the client). 
% TODO CarRentalCompany remote??

\subsection{Sessions life time management}
The rental session keeps a conversational state and it is unique in respect of a client. \texttt{SessionManager} acts as a naming service for the rental sessions and enables a renter to create their own session. At the end of their work, the renter can end the session. The ending causes the deletion of the kept state, if any. This means if there are some unconfirmed quotes when the client closes the session, they are removed. We binds clients and session via a \texttt{Map$<$String, RentalSession$>$}, where the \texttt{String} represents the client's name, supposed to be unique.
% TODO: what if the client doesn't terminate the session? Shall we end it after a while or shell we keep it alive and return the same session if the client asks for that? 

Rental sessions are not persistent over server failures. If the server keeping the conversational state crashes, every information about the sessions, as well as every information about the reservations, is lost. We do not deal with this design issue because data persistence is not one of this assignment's goals. 

The manager session does not keep any conversational state, and it is represented as a simple remote objects. Managers simply obtain a reference to this object by looking up in the \texttt{rmi registry} and use this reference to invoke methods. They play no role in managing its lifetime. A manager session can be open on the fly without the need of the aforementioned binding.

\subsection{Thread synchronization}
The main synchronization point is about quotes confirmation. Different threads (i.e. different clients) may autonomously create quotes, which might conflict with one another. To preserve server-side data consistency, only one client at a time must be allowed to confirm its quotes with respect to a particular rental company. In order to achieve this we could mark as \texttt{synchronized} either the method \texttt{RentalSession.confirmQuotes} or \\\texttt{CarRentalCompany.confirmQuote}. Both have advantages and disadvantages. On the one hand, with the former only \textit{one} client at a time, say $C_1$, would be allowed to confirm its quotes. The other clients would have to wait, even if they do not have quotes corresponding to the companies targeted by $C_1$. This would be a serious bottleneck. The latter, on the other hand, allows clients to confirm in parallel quotes to different rental companies. They cannot, however, confirm in parallel quotes to the same company. Anyway, this solutions breaks the \textbf{isolation} property. Consider a client $C_1$ which succeeds in confirming a quote to the company $R_1$, but does not succeed in confirming a quote for the company $R_2$. Consider also another client, $C_2$, trying to reserve the same car as $C_1$ for $R_1$, and for which the confirmations fails because $C_1$ has arrived earlier. After the $C_1$'s failure with respect to $R_2$, the first reservation has to be deleted and this would make it possible for $C_2$ to reserve the car, but $C_2$ has already failed. In this case $C_2$ had seen a partial effect of $C_1$'s transaction. This breaks the isolation property, and is the reason why we chose to apply a more coarse-grained synchronization (i.e. the first solution), even if it represents a bottleneck.

\texttt{ManagerSession} has a synchronization point too. It is used by managers to register and unregister companies to the naming service. The access to these two write operations must be synchronized to achieve thread-safety. We do not consider it as a bottleneck. Manager are supposed to be less than clients, and register and unregister operations are supposed to be far less frequent than quotes confirmations. Furthermore, quotes confirmation may take a variable amount of time, depending on how many quotes the client is trying to confirm. On the contrary, registering (or unregistering) a company to (respectively, from) the naming service only requires an append (respectively, a lookup and a remotion), which is, considering the application, much faster than the confirmation flow.