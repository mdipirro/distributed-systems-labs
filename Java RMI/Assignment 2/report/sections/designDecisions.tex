\section{Design decisions}
\subsection{Remote and Serializable classes}
The three interfaces defined in the \texttt{session} package (\texttt{AgencySessionManagerRemote}, \\\texttt{RentalSessionRemote}, and \texttt{ManagerSessionRemote}) are remotely accessible (i.e. they are stereotyped with \texttt{$<<$Remote$>>$}) in the class diagram. This design choice follows the Java RMI's standard mandate. After defining the interfaces as \texttt{$<<$Remote$>>$} we can use them as remote objects. This allows the client to ignore any implementation details and act considering the remote interface only. The actual code can be dynamically downloaded or distributed as a \texttt{.jar} file.

We also define \texttt{CarRentalCompany} and \texttt{NamingService} as remote accessibly. Their remote interfaces are, respectively, \texttt{CarRentalCompanyRemote} and \texttt{NamingServiceRemote}. Regarding the former, this design decision follows immediately from the requirement stating that every car rental company might run on a different server. The latter follows from common sense, since a naming service should not be a local object. Instead, it should be remotely accessible from every other part to be queried.

We make serializable (i.e. stereotyped as \texttt{$<<$Serializable$>>$}) only the classes intended to be marshaled and unmarshaled. These classes do not include the remote accessible ones, since Java RMI sends a remote reference for them, and not an object copy. The following classes are serializable: \texttt{ReservationException}, \texttt{ReservationConstraint}, \texttt{CarType}, \texttt{Quote}, \texttt{Reservation}, and \texttt{Car}. Instances of these classes are used as parameters or return values by remote object's methods. As mentioned before, Java RMI uses a pass-by-value semantics for non-remote objects, which involves marshaling and unmarshaling. Since instances of the other classes in the \texttt{rental} package are not sent over the network, those classes do not implement the \texttt{Serializable} interface. 

\subsection{Location of remote objects}
The only two objects located in the same node are \texttt{AgencySessionManager} and \texttt{ReservationSession}. The coupling between these two classes is high, since the former creates instances of the latter and maintains a binding with clients. Locating them on the same host is necessary since session instances are created on the fly when needed. It stores them ``locally'' and returns only a remote reference to them. 

The situation is different for \texttt{CarRentalCompany} and \texttt{NamingService}. The latter acts both as a lookup service and as a manager for the former. The main difference relies on the fact that rental companies can be created independently on the naming service, while rental sessions exists only while bound with clients. 

We deploy every other object independently on the others, taking advantage of RMI. Different components use different objects based on their needs, but the coupling among them is low: they hold only a remote reference and see only the methods exposed by the remote interface. This makes the application fully distribute and easily extensible. 

\subsection{Registration of remote objects}
We register to the built-in RMI registry one instance for each of the following three interfaces: \texttt{AgencySessionManagerRemote}, \texttt{ManagerSessionRemote}, and \texttt{NamingServiceRemote}. Since these instances cannot be obtained in any other ways, it is necessary to expose them using the RMI registry. On the contrary, we do not expose instances of \texttt{RentalSession} and \texttt{CarRentalCompany}. The former are returned as a result of the \texttt{AgencySessionManagerRemote.add} invocation. Providing the access to an instance of this class via the RMI register would be wrong, since a rental session does not exist without a binding with a renter. The latter can be retrieved using the naming service.
Since managers can dynamically register and unregister companies, a bound with the register would be wrong. The naming service is responsible for keeping the bind $<$remote company, company's name$>$, so that a lookup is feasible by using the company's name only.

\subsection{Sessions life time management}
The rental session keeps a conversational state and it is unique in respect of a client. \\\texttt{AgencySessionManagerRemote} acts as a naming service for the rental sessions and enables a renter to create their own session. At the end of their work, the renter can end the session. The ending causes the deletion of the kept state, if any. This means if there are some unconfirmed quotes when the client closes the session, they are removed. We bind clients and session via a \texttt{Map$<$String, RentalSession$>$}, where the \texttt{String} represents the client's name, supposed to be unique. When a session is terminated the binding is removed from the map, and the session is marked as \texttt{terminated}. From now on, every attempt of a remote method invocation results in a \texttt{RemoteException}. We keep alive the session if the client does not explicitly terminate it. If a session bound with the client name exists when \texttt{AgencySessionManagerRemote.getRentalSession} is invoked, that session is returned instead of a new one. Clients may check the state by invoking \texttt{RentalSession.getCurrentQuotes}.

Rental sessions are not persistent over server failures. If the server keeping the conversational state crashes, information about the sessions, as well as data about the reservations, is lost. We do not deal with this design issue because data persistence is not one of this assignment's goals. 

The manager session does not keep any conversational state, and it is represented as a simple remote objects. Managers simply obtain a reference to this object by looking up in the \texttt{rmi registry} and use this reference to invoke methods. They play no role in managing its lifetime. A manager session can be open on the fly without the need of the aforementioned binding.

We keep completely separate what concerns rental sessions and what concerns manager session. We could have used \texttt{AgencySessionManagerRemote} also for managing the latter. Nonetheless, clients could have obtained a reference to the manager session. By binding these objects separately in the RMI registry we are sure that renters cannot accidentally obtain references to a manager session, and vice versa.

\subsection{Thread synchronization}
The main synchronization point is about quotes confirmation. Different threads (i.e. different clients) may autonomously create quotes, which might conflict with one another. To preserve server-side data consistency, only one client at a time must be allowed to confirm its quotes with respect to a particular rental company. We mark as \texttt{synchronized} the \texttt{confirmQuote} method in \texttt{CarRentalCompany}. In this way, different renters cannot confirm at the same time quotes to the same car rental company, but they can confirm in parallel quotes to different companies. Synchronization at this point might be a serious bottleneck, since the locking time depends on how many quotes a specific renter is trying to confirm. This solution guarantees data consistency, but breaks the isolation property. Consider a client $C_1$ which succeeds in confirming a quote to the company $R_1$, but does not succeed in confirming a quote for the company $R_2$. Consider also another client, $C_2$, trying to reserve the same car as $C_1$ for $R_1$, and for which the confirmations fails because $C_1$ has arrived earlier. After the $C_1$'s failure with respect to $R_2$, the first reservation has to be deleted and this would make it possible for $C_2$ to reserve the car, but $C_2$ has already failed. In this case $C_2$ had seen a partial effect of $C_1$'s transaction. Nevertheless, this assignment is not about implementing distributed transactions. 

For a similar reasoning we also synchronize the method \texttt{removeQuote} in \texttt{CarRentalCompany}.

\texttt{ManagerSession} has a synchronization point too. It is used by managers to register and unregister companies to the naming service. The access to these two write operations must be synchronized to achieve thread-safety. We do not consider it as a bottleneck. Manager are supposed to be less than clients, and register and unregister operations are supposed to be far less frequent than quotes confirmations. Furthermore, quotes confirmation may take a variable amount of time, depending on how many quotes the client is trying to confirm. On the contrary, registering (or unregistering) a company to (respectively, from) the naming service only requires an append (respectively, a lookup and a remotion), which is, considering the application, much faster than the confirmation flow. We synchronize the corresponding methods in \texttt{NamingService} (i.e. \texttt{addCompany} and \texttt{removeCompany}) instead of \texttt{register} and \texttt{unregister}. As we said, the naming service is accessible from the RMI register, as well as the manager session. If two different threads invoke, at the same time, \texttt{register} and \texttt{addCompany}, synchronization does not take place if we only apply it on the former. This might lead to a possible (even if rare) data inconsistency configuration. 

Lastly, we synchronize the creation and the remotion of a rental session (i.e. \texttt{getRentalSession} and \texttt{terminateRentalSession} in \texttt{AgencySessionManager}). Again, we do not consider this as a bottleneck, since clients are supposed to create a session and to work with it instead of creating new sessions continuously.

Since the latter two synchronization points only involve operations on a single \texttt{Map}, we rely on Java's \texttt{ConcurrentHashMap}. Synchronization acts only at the map level, with concurrent and fast reads. Writes are done with a lock. We cannot use the same solution for the former synchronization point. That transaction involves operations on possibly more than one map, so a more coarse-grained synchronization is needed. Otherwise the isolation property is not guaranteed anymore.